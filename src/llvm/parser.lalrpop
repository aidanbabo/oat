// todo: custom parser (much faster? and less dependencies)
use internment::{Arena, ArenaIntern};
use std::str::FromStr;
use crate::llvm::ast;
use crate::llvm::parser_utils::{append, escape_string, gensym};

grammar<'ast>(arena: &'ast Arena<str>);

match {
	// eof => EOF,
	r"[\t ]" => {},
	r"\n|(\r\n)|\r" => {},
	r#"c"([^"\\]|(\\")|(\\00))*""# => UNESCAPED_STRING,
	"*" => STAR,
	","=> COMMA,
	":" => COLON,
	"=" => EQUALS,
	"(" => LPAREN,
	")" => RPAREN,
	"{" => LBRACE,
	"}" => RBRACE,
	"[" => LBRACKET,
	"]" => RBRACKET,
	"i1" => I1,
	"i8" => I8,
	"i32" => I32,
	"i64" => I64,
	"to" => TO,
	"br" => BR,
	"eq" => EQ,
	"ne" => NE,
	"or" => OR,
	"and" => AND,
	"add" => ADD,
	"sub" => SUB,
	"mul" => MUL,
	"xor" => XOR,
	"slt" => SLT,
	"sle" => SLE,
	"sgt" => SGT,
	"sge" => SGE,
	"shl" => SHL,
	"ret" => RET,
	"getelementptr" => GEP,
	"type" => TYPE,
	"null" => NULL,
	"lshr" => LSHR,
	"ashr" => ASHR,
	"call" => CALL,
	"icmp" => ICMP,
	"void" => VOID,
	"load" => LOAD,
	"entry" => ENTRY,
	"store" => STORE,
	"label" => LABEL,
	"global" => GLOBAL,
	"define" => DEFINE,
	"declare" => DECLARE,
	"external" => EXTERNAL,
	"alloca" => ALLOCA,
	"bitcast" => BITCAST,
	r"%\.?[A-Za-z\d_][A-Za-z\d_\.]*" => UID_RAW,
	r"\@\.?[A-Za-z\d_][A-Za-z\d_\.]*" => GID_RAW,
	"x" => CROSS,
	r"\d+" => INT,
	r";([^\n\r])*\n" => {}, // comments
} else {
	r"[A-Za-z\d_][A-Za-z\d_\.]*" => LBL_RAW,
}

pub Prog: ast::Prog<'ast> = <Decls>;

Decls: ast::Prog<'ast> = {
	() => ast::Prog { 
		tdecls: Default::default(),
		gdecls: Default::default(),
		fdecls: Default::default(),
		edecls: Default::default(),
	},
	<mut ds:Decls> <f:Fdecl> => {
		ds.fdecls.push(f);
		ds
	},
	<mut ds:Decls> <g:Gdecl> => {
		ds.gdecls.push(g);
		ds
	},
	<mut ds:Decls> <t:Tdecl> => {
		ds.tdecls.insert(t.0, t.1);
		ds
	},
	<mut ds:Decls> <e:Edecl> => {
		ds.edecls.push(e);
		ds
	},
};

Fdecl: (ast::Gid<'ast>, ast::Fdecl<'ast>) = {
	DEFINE <t:Ty> <l:GID> LPAREN <a:ArgList> RPAREN
	LBRACE <eb:EntryBlock> <bs:BlockList> RBRACE => {
		let (ptys, pnames) = a.into_iter().unzip();
		(l, ast::Fdecl {
			ty: ast::FunTy {
				params: ptys,
				ret: t,
			},
			params: pnames,
			cfg: ast::Cfg { entry: eb, blocks: bs },
		})
	}
};

Gdecl: (ast::Gid<'ast>, ast::Gdecl<'ast>) = {
	<g:GID> EQUALS GLOBAL <t:Ty> <gi:Ginit> => (g, (t, gi)),
};

Tdecl: (ast::Tid<'ast>, ast::Ty<'ast>) = {
	<tid:UID> EQUALS TYPE <t:Ty> => (tid, t),
};

Edecl: (ast::Gid<'ast>, ast::Ty<'ast>) = {
	DECLARE <rt:Ty> <g:GID> LPAREN <ts:Comma<Ty>> RPAREN => (g, ast::Ty::Fun(ts, Box::new(rt))),
	<g:GID> EQUALS EXTERNAL GLOBAL <t:Ty> => (g, t),
};

NonPtrTy: ast::Ty<'ast> = {
	VOID => ast::Ty::Void,
	I1 => ast::Ty::I1,
	I8 => ast::Ty::I8,
	I64 => ast::Ty::I64,
	LBRACE <ts:TyList> RBRACE => ast::Ty::Struct(ts),
	LBRACKET <i:INT> CROSS <t:Ty> RBRACKET => ast::Ty::Array(i64::from_str(i).unwrap(), Box::new(t)),
	<rt:Ty> LPAREN <ts:TyList> RPAREN => ast::Ty::Fun(ts, Box::new(rt)),
	<t:UID> => ast::Ty::Named(t),
};

Ty: ast::Ty<'ast> = {
	<t:Ty> STAR => ast::Ty::Ptr(Box::new(t)),
	NonPtrTy => <>,
};

TyList: Vec<ast::Ty<'ast>> = {
	Ty => vec![<>],
	<ts:TyList> COMMA <t:Ty> => append(ts, t),
};

Arg: (ast::Ty<'ast>, ast::Uid<'ast>) = {
	<t:Ty> <u:UID> => (t, u),
};

// hereherhehrherh
ArgList: Vec<(ast::Ty<'ast>, ast::Uid<'ast>)> = {
	() => vec![],
	Arg => vec![<>],
	<args:ArgList> COMMA <a:Arg> => append(args, a),
};

Operand: ast::Operand<'ast> = {
	NULL => ast::Operand::Null,
	INT => ast::Operand::Const(i64::from_str(<>).unwrap()),
	GID => ast::Operand::Gid(<>),
	UID => ast::Operand::Id(<>),
};

TyOperandList: Vec<(ast::Ty<'ast>, ast::Operand<'ast>)> = {
	() => vec![],
	Ty Operand => vec![(<>)],
	<tos:TyOperandList> COMMA <t:Ty> <o:Operand> => append(tos, (t, o)),
};

IOperandList: Vec<ast::Operand<'ast>> = {
	() => vec![],
	I64 <Operand> => vec![<>],
	I32 <Operand> => vec![<>],
	<os:IOperandList> COMMA I64 <o:Operand> => append(os, o),
	<os:IOperandList> COMMA I32 <o:Operand> => append(os, o),
};

Terminator: ast::Terminator<'ast> = {
	RET <t:Ty> <o:Operand> => ast::Terminator::Ret(t, Some(o)),
	RET <t:Ty> => ast::Terminator::Ret(t, None),
	BR LABEL <l:UID> => ast::Terminator::Br(l),
	BR I1 <o:Operand> COMMA LABEL <l1:UID> COMMA LABEL <l2:UID> => ast::Terminator::Cbr(o, l1, l2),
};

Block: ast::Block<'ast> = {
	<is:InsnList> <t:Terminator> => ast::Block {
		insns: is,
		term: (gensym(arena, "tmn"), t),
	},
}

BlockList: Vec<(ast::Lbl<'ast>, ast::Block<'ast>)> = {
	() => vec![],
	<bs:BlockList> <l:LBL> COLON <b:Block> => append(bs, (l, b)),
};

EntryBlock: ast::Block<'ast> = {
	ENTRY COLON <Block> => <>,
	Block => <>
};

Bop: ast::Bop = {
	OR => ast::Bop::Or,
	ADD => ast::Bop::Add,
	SUB => ast::Bop::Sub,
	MUL => ast::Bop::Mul,
	SHL => ast::Bop::Shl,
	XOR => ast::Bop::Xor,
	AND => ast::Bop::And,
	LSHR => ast::Bop::Lshr,
	ASHR => ast::Bop::Ashr,
};

Cnd: ast::Cnd = {
	EQ => ast::Cnd::Eq,
	NE => ast::Cnd::Ne,
	SLT => ast::Cnd::Slt,
	SLE => ast::Cnd::Sle,
	SGT => ast::Cnd::Sgt,
	SGE => ast::Cnd::Sge,
};

Insn: (ast::Uid<'ast>, ast::Insn<'ast>) = {
	<u:UID> EQUALS <b:Bop> <t:Ty> <o1:Operand> COMMA <o2:Operand> => (u, ast::Insn::Binop(b, t, o1, o2)),
	<u:UID> EQUALS ALLOCA <t:Ty> => (u, ast::Insn::Alloca(t)),
	<u:UID> EQUALS LOAD <t:Ty> COMMA Ty <o:Operand> => (u, ast::Insn::Load(t, o)),
	STORE <t1:Ty> <o1:Operand> COMMA <_t2:Ty> <o2:Operand> => (gensym(arena, "store"), ast::Insn::Store(t1, o1, o2)),
	<u:UID> EQUALS ICMP <c:Cnd> <t:Ty> <o1:Operand> COMMA <o2:Operand> => (u, ast::Insn::Icmp(c, t, o1, o2)),
	CALL <t:Ty> <o:Operand> LPAREN <args:TyOperandList> RPAREN => (gensym(arena, "call"), ast::Insn::Call(t, o, args)),
	<u:UID> EQUALS CALL <t:Ty> <o:Operand> LPAREN <args:TyOperandList> RPAREN => (u, ast::Insn::Call(t, o, args)),
	<u:UID> EQUALS BITCAST <t1:Ty> <o:Operand> TO <t2:Ty> => (u, ast::Insn::Bitcast(t1, o, t2)),
	<u:UID> EQUALS GEP <t:Ty> COMMA Ty <o:Operand> COMMA <os:IOperandList> => (u, ast::Insn::Gep(t, o, os)),
};

InsnList: Vec<(ast::Uid<'ast>, ast::Insn<'ast>)> = <(Insn)*> => <>;

GdeclList: Vec<(ast::Ty<'ast>, ast::Ginit<'ast>)> = {
	() => vec![],
	Ty Ginit => vec![(<>)],
	<gs:GdeclList> COMMA <t:Ty> <g:Ginit> => append(gs, (t, g)),
};

Ginit: ast::Ginit<'ast> = {
	NULL => ast::Ginit::Null,
	GID => ast::Ginit::Gid(<>),
	INT => ast::Ginit::Int(i64::from_str(<>).unwrap()),
	UNESCAPED_STRING => ast::Ginit::String(escape_string(<>)),
	LBRACKET <GdeclList> RBRACKET => ast::Ginit::Array(<>),
	LBRACE <GdeclList> RBRACE => ast::Ginit::Struct(<>),
	BITCAST LPAREN <t1:Ty> <g:Ginit> TO <t2:Ty> RPAREN => ast::Ginit::Bitcast(t1, Box::new(g), t2),
};

Comma<T>: Vec<T> = {
    <v:(<T> COMMA)*> <e:T?> => match e {
        None => v,
        Some(e) => append(v, e),
    }
};

UID: ArenaIntern<'ast, str> = UID_RAW => arena.intern(&<>[1..]);
GID: ArenaIntern<'ast, str> = GID_RAW => arena.intern(&<>[1..]);
LBL: ArenaIntern<'ast, str> = LBL_RAW => arena.intern(<>);
