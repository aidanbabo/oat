// todo: directives
// todo: nested comments

use crate::oat::ast;
use crate::oat::parser_utils::escape_string;

grammar;

match {
	"null" => NULL,
	"void" => TVOID,
	"int" => TINT,
	"bool" => TBOOL,
	"true" => TRUE,
	"false" => FALSE,
	"string" => TSTRING,
	"if" => IF,
	// "if?" => IFQ,
	"else" => ELSE,
	"while" => WHILE,
	"for" => FOR,
	"return" => RETURN,
	"var" => VAR,
	// "struct" => STRUCT,
	"global" => GLOBAL,
	"new" => NEW,
	"length" => LENGTH,
	";" => SEMI,
	"," => COMMA,
	"." => DOT,
	"{" => LBRACE,
	"}" => RBRACE,
	"*" => STAR,
	"+" => PLUS,
	"-" => DASH,
	"=" => EQ,
	"==" => EQEQ,
	"!" => BANG,
	"~" => TILDE,
	"(" => LPAREN,
	")" => RPAREN,
	"[" => LBRACKET,
	"]" => RBRACKET,
	"<<" => LTLT,
	">>" => GTGT,
	">>>" => GTGTGT,
	"<" => LT,
	"<=" => LTEQ,
	">" => GT,
	">=" => GTEQ,
	"!=" => BANGEQ,
	"&" => AMPER,
	"|" => BAR,
	"[&]" => IAND,
	"[|]" => IOR,
	"->" => ARROW,
	"?" => QUESTION,
	r"[0-9]+" => INTLIT,
	r"0x[0-9a-fA-F]+" => HEXINTLIT,
	r"[a-z][0-9a-zA-z_]*" => IDENT,
	r"[A-Z][0-9a-zA-z_]*" => UIDENT,
	r#"(".*[^\\]")|("")"# => UNESCAPED_STRING,
}

pub Prog: ast::Prog = <Decl*> => <>;

Decl: ast::Decl = {
	GLOBAL <name:IDENT> EQ <init:Gexpr> SEMI => ast::Decl::Var(ast::Node::no_loc(ast::Gdecl { name: name.to_string(), init })),
	<ret_ty:RetTy> <name:IDENT> LPAREN <args:Separated<COMMA, Arg>> RPAREN <body:Block> => ast::Decl::Fun(ast::Node::no_loc(ast::Fdecl { ret_ty, name: name.to_string(), args, body })),
	// STRUCT <name:IDENT> LBRACE <fields:Separated<SEMI, FieldDecl>> RBRACE => ast::Decl::Type(ast::Node::no_loc(ast::Tdecl { <> })),
};

FieldDecl: ast::Field = <ty:Ty> <name:IDENT> => ast::Field { ty, name: name.to_string() };

Arg: (ast::Ty, ast::Ident) = <t:Ty> <id:IDENT> => (t, id.to_string());

Ty: ast::Ty = {
	TBOOL => ast::Ty::Bool,
	TINT => ast::Ty::Int,
	<RefTy> => ast::Ty::Ref(Box::new(<>)),
	<NonFunRefTy> QUESTION => ast::Ty::NullRef(Box::new(<>)),
	LPAREN <Ty> RPAREN => <>,
}

RetTy: ast::RetTy = {
	TVOID => ast::RetTy::Void,
	<Ty> => ast::RetTy::Val(<>),
}

RefTy: ast::RefTy = {
	LPAREN RPAREN ARROW <RetTy> => ast::RefTy::Fun(vec![], Box::new(<>)),
	LPAREN <t:Ty> RPAREN ARROW <ret_ty:RetTy> => ast::RefTy::Fun(vec![t], Box::new(ret_ty)),
	LPAREN <t:Ty> COMMA <mut ts:Separated<COMMA, Ty>> RPAREN ARROW <ret_ty:RetTy> => {
		ts.insert(0, t);
		return ast::RefTy::Fun(ts, Box::new(ret_ty));
	},
	TSTRING => ast::RefTy::String,
	<NonFunTy> LBRACKET RBRACKET => ast::RefTy::Array(<>),
	<UIDENT> => ast::RefTy::Struct(<>.to_string()),
}

NonFunTy: ast::Ty = {
	TBOOL => ast::Ty::Bool,
	TINT => ast::Ty::Int,
	<NonFunRefTy> => ast::Ty::Ref(Box::new(<>)),
	<NonFunRefTy> QUESTION => ast::Ty::NullRef(Box::new(<>)),
	LPAREN <Ty> RPAREN => <>,
}

NonFunRetTy: ast::RetTy = {
	TVOID => ast::RetTy::Void,
	<NonFunTy> => ast::RetTy::Val(<>),
}

NonFunRefTy: ast::RefTy = {
	TSTRING => ast::RefTy::String,
	<NonFunTy> LBRACKET RBRACKET => ast::RefTy::Array(<>),
	<UIDENT> => ast::RefTy::Struct(<>.to_string()),
}

Uop: ast::Unop = {
	DASH => ast::Unop::Neg,
	BANG => ast::Unop::LogNot,
	TILDE => ast::Unop::BitNot,
}

Gexpr: ast::Node<ast::Exp> = {
	<RefTy> NULL => ast::Node::no_loc(ast::Exp::Null(<>)),
	TRUE => ast::Node::no_loc(ast::Exp::Bool(true)),
	FALSE => ast::Node::no_loc(ast::Exp::Bool(false)),
	INTLIT => ast::Node::no_loc(ast::Exp::Int(0)),
	UNESCAPED_STRING => ast::Node::no_loc(ast::Exp::Str(<>.to_string())),
	NEW <t:Ty> LBRACKET RBRACKET LBRACE <cs:Separated<COMMA, Gexpr>> RBRACE => ast::Node::no_loc(ast::Exp::ArrElems(t, cs)),
	// NEW <i:IDENT> LBRACE <cs:Separated<SEMI, Gfield>> RBRACE => ast::Node::no_loc(ast::Exp::Struct(i, fs)),
	<IDENT> => ast::Node::no_loc(ast::Exp::Id(<>.to_string())),
}

Gfield: (ast::Ident, ast::Node<ast::Exp>) = <id:IDENT> EQ <e:Gexpr> => (id.to_string(), e);

Lhs: ast::Node<ast::Exp> = {
	<IDENT> => ast::Node::no_loc(ast::Exp::Id(<>.to_string())),
	<e:Exp> LBRACKET <i:Exp> RBRACKET => ast::Node::no_loc(ast::Exp::Index(Box::new(e), Box::new(i))),
	// <e:Exp> DOT <id:IDENT> => ast::Node::no_loc(ast::Exp::Prog(Box::new(e), id.to_string())),
}

Exp: ast::Node<ast::Exp> = {
	<RefTy> NULL => ast::Node::no_loc(ast::Exp::Null(<>)),
	TRUE => ast::Node::no_loc(ast::Exp::Bool(true)),
	FALSE => ast::Node::no_loc(ast::Exp::Bool(false)),
	INTLIT => ast::Node::no_loc(ast::Exp::Int(0)),
	UNESCAPED_STRING => ast::Node::no_loc(ast::Exp::Str(<>.to_string())),
	NEW <t:Ty> LBRACKET RBRACKET LBRACE <cs:Separated<COMMA, Exp>> RBRACE => ast::Node::no_loc(ast::Exp::ArrElems(t, cs)),
	NEW <t:Ty> LBRACKET <e1:Exp> RBRACKET => ast::Node::no_loc(ast::Exp::ArrLen(t, Box::new(e1))),
	// NEW <i:IDENT> LBRACE <cs:Separated<SEMI, Field>> RBRACE => ast::Node::no_loc(ast::Exp::Struct(i, fs)),
	// NEW <t:Ty> LBRACKET <e1:Exp> RBRACKET LBRACE <u:IDENT> ARROW <e2:Exp> RBRACE => ast::Node::no_loc(ast::Exp::ArrInit(ty, Box::new(e1), u, Box::new(e2))),
	<IDENT> => ast::Node::no_loc(ast::Exp::Id(<>.to_string())),
	<u:Uop> <e:Exp> => ast::Node::no_loc(ast::Exp::Uop(u, Box::new(e))),
	LENGTH LPAREN <Exp> RPAREN => ast::Node::no_loc(ast::Exp::Length(Box::new(<>))),
	// #[precedence(level="1")]
	// #[assoc(side="left")]
	// <l:Exp> IOR <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::IOr, Box::new(l), Box::new(r))),
	// #[precedence(level="2")]
	// <l:Exp> IAND <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::IAnd, Box::new(l), Box::new(r))),
	// #[precedence(level="3")]
	// <l:Exp> BAR <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::Or, Box::new(l), Box::new(r))),
	// #[precedence(level="4")]
	// <l:Exp> AMPER <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::And, Box::new(l), Box::new(r))),
	// #[precedence(level="5")]
	// <l:Exp> EQEQ <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::Eq, Box::new(l), Box::new(r))),
	// <l:Exp> BANGEQ <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::Neq, Box::new(l), Box::new(r))),
	// #[precedence(level="6")]
	// <l:Exp> LT <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::Lt, Box::new(l), Box::new(r))),
	// <l:Exp> LTEQ <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::Lte, Box::new(l), Box::new(r))),
	// <l:Exp> GT <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::Gt, Box::new(l), Box::new(r))),
	// <l:Exp> GTEQ <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::Gte, Box::new(l), Box::new(r))),
	// #[precedence(level="7")]
	// <l:Exp> LTLT <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::Shl, Box::new(l), Box::new(r))),
	// <l:Exp> GTGT <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::Shr, Box::new(l), Box::new(r))),
	// <l:Exp> GTGTGT <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::Sar, Box::new(l), Box::new(r))),
	// #[precedence(level="8")]
	// <l:Exp> PLUS <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::Add, Box::new(l), Box::new(r))),
	// <l:Exp> DASH <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::Sub, Box::new(l), Box::new(r))),
	// #[precedence(level="9")]
	// <l:Exp> STAR <r:Exp> => ast::Node::no_loc(ast::Exp::Binop(ast::Bop::Mul, Box::new(l), Box::new(r))),
	// #[precedence(level="10")]
	// <e:Exp> DOT <id:IDENT> => ast::Node::no_loc(ast::Exp::Proj(Box::new(e), id)),
	// #[precedence(level="11")]
	// <e:Exp> LBRACKET <i:Exp> RBRACKET => ast::Node::no_loc(ast::Exp::Index(Box::new(e), Box::new(i))),
	// <e:Exp> LPAREN <es:Separated<COMMA, Exp>> RPAREN => ast::Node::no_loc(ast::Exp::Call(Box::new(e), es)),
	// #[precedence(level="12")]
	// LPAREN <Exp> RPAREN => <>,
}

Field: (ast::Ident, ast::Node<ast::Exp>) = <id:IDENT> EQ <e:Exp> => (id.to_string(), e);

Vdecl: ast::Vdecl = VAR <name:IDENT> EQ <exp:Exp> => ast::Vdecl { name: name.to_string(), exp };

Stmt: ast::Node<ast::Stmt> = {
	<d:Vdecl> SEMI => ast::Node::no_loc(ast::Stmt::Decl(d)),
	<p:Lhs> EQ <e:Exp> SEMI => ast::Node::no_loc(ast::Stmt::Assn(p, e)),
	<e:Exp> LPAREN <es:Separated<COMMA, Exp>> RPAREN SEMI => ast::Node::no_loc(ast::Stmt::Call(e, es)),
	<IfStmt> => <>,
	RETURN <Exp?> SEMI => ast::Node::no_loc(ast::Stmt::Ret(<>)),
	WHILE LPAREN <e:Exp> RPAREN <b:Block> => ast::Node::no_loc(ast::Stmt::While(e, b)),
	FOR LPAREN <ds:Separated<COMMA, Vdecl>> SEMI <e:Exp?> SEMI <s:Stmt?> RPAREN <b:Block> => ast::Node::no_loc(ast::Stmt::For(ds, e, s.map(Box::new), b)),
}

Block: Vec<ast::Node<ast::Stmt>> = LBRACE <Stmt*> RBRACE => <>;

IfStmt: ast::Node<ast::Stmt> = {
	IF LPAREN <e:Exp> RPAREN <b1:Block> <b2:ElseStmt?> => ast::Node::no_loc(ast::Stmt::If(e, b1, b2.unwrap_or_default())),
	// IFQ LPAREN <r:RefTy> <id:IDENT> EQ <e:Exp> RPAREN <b1:Block> <b2:ElseStmt?> => ast::Node::no_loc(ast::Stmt::IfNull(r, id, e, b1, b2.unwrap_or_default())),
}

ElseStmt: ast::Block = {
	ELSE <Block> => <>,
	ELSE <IfStmt> => vec![<>],
}

// Separated<Sep, T>: Vec<T> = {
//     <v:(<T> Sep)*> <e:T?> => match e {
//         None => v,
//         Some(e) => append(v, e),
//     }
// }

Separated<Sep, T>: Vec<T> = <Sepped<Sep, T>?> => <>.unwrap_or_default();

Sepped<Sep, T>: Vec<T> = {
    <e:T> <mut v:(Sep <T>)*> => {
	v.insert(0, e);
	v
    }
}
